Guidelines
(work in progress)

If  you  want  to  contribute   to  Ocsimore  and/or  write  your  own
extensions, we recommend to follow these guidelines:

 - Please try to make things as generic and configurable as possible.

 - The use of classes allows to extend widgets or modify their behaviours.
Decompose each of them into several methods, one for each subtask to perform
(retrieve data, display ...) and for each widget kind.

 - Decompose your module in 5 parts:
_createdb.sql SQL creation of databases
_sql.ml database requests, using lwt-pgocaml and lwt_pool
.ml defining and exporting session data for the module (see below)
_cache.ml cache on database requests, using the Cache module
_widgets.ml your widgets

For all cached requests, I use a name ending with _ in *_sql.ml to and without
the _ in *cache.ml to remember that we must not call the functions from
_sql.ml directly.

 - Use as much as possible the same naming scheme for methods.
For example:
* private retrieve_data or retrieve_...
* private display or display_... for displaying the widget from retrieved data
* public methods for each widget you want to be able to put in your pages
(possibly in wikipages), that will:
  1. check permissions
  2. call retrieve_...
  3. call display_...
For example: public method oldversion_wikibox will call retrieve_old_wikibox
and display_old_wikibox

 - Use as much as possible the same names for labels.

 - Each widget takes an optional ?classe label of type string list
for the class xhtml attribute. Each widget has its own attribute names

 - Session data:
most widgets take ~sp as parameter (Eliom's server parameters) and also
a ~sd parameter (session data).
This ~sd parameter is a cache of session data, to avoid retrieving
them from the db for each box, if several boxes need them.
It has type Ocsimore_common.session_data = Polytables.t
(polymorphic table).
This allows each module (forum, wiki...) to save its own data inside.
To do that, each module must create its own polytable key.
This data is usually a record with lazy values or tables inside 
to prevent data to be retrieved if not necessary of if it has already been done.
You must create a new ~sd for each request using
Ocsimore_common.create_sd (it is destroyed at the end).
See for example wiki.ml.

Is it really useful? Actually I use it only for few things. For most cases,
we use a cache of sql requests.

Warning: Polytables is not thread-safe. Do not use function that access ~sd
inside Lwt_preemptive.detach!

When doing an action, DO NOT FORGET to send the session data to the
subsequent service by returning the exception Ocsimore_common.Session_data.
At the beginning of a service handler, call Ocsimore_common.get_sd
that will get the previous sd if it exists, or create a new one otherwise.

 - Catching exceptions:
To be sure that all exceptions occurring during a db request are catched
and result in an error message in the box, I use the method
Widget.widget_with_error_box#bind_or_display_error

 - Creating new wiki extensions:
If you create a new box, you probably want to have a syntax to place it
inside a wikibox. To so that, use the functions Wiki_syntax.add_block_extension
and Wiki_syntax.add_inline_extension. 
If you want a preparsing (i.e. do some action before saving the wikibox in
the database, like creating a new wikibox for <<wikibox box='new'>>),
use the function Wiki_filter.add_preparser_extension.
If your box can contain wiki syntax,
(for example <<div|content>>) do not forget to call
Wiki_filter.add_preparser_extension as in Wiki_syntax.ml (div)
to preparse the content recursively.
(!!!Very dangerous: should be done automatically!!!)
See examples in wiki_syntax.ml ans wiki_widgets.ml

 - Groups
Groups and users are the same notion. The only difference is that users have
a password. A user can belong to a group that belongs to another group, etc.
It is recommanded to create groups for each task you want. For example:
readers of wiki 1, writers of wiki 1, and then put users inside.
Predefined users/groups:
 - admin: a special user who belongs to all groups
 - anonymous: non authenticated user
 - users: group of authenticated users
 - nobody: a special user with no right at all 
 (for ex when the user does not exist)
