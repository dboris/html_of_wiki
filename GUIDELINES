===Guidelines and implementation notes===
(work in progress)

If  you  want  to  contribute   to  Ocsimore  and/or  write  your  own
extensions, we recommend to follow these guidelines:

* Please try to make things as generic and configurable as possible.

* The use of classes allows to extend widgets or modify their behaviours.
Decompose each of them into several methods, one for each subtask to perform
(retrieve data, display ...) and for each widget kind.

The instanciation of classes must be done in a separate module, that
can be rewritten by programmers who want to redefine some methods.

* The creation and registration of services is also done in this
  separate module that can be loaded several times inside the
  {{{<host>}}} section of the configuration file. 

  Usually, widgets depend on services, and service handlers depend on
  widgets. This means that there is an instance of classes for each
  site. For example, create services, then give them as parameters to
  the class constructor to create the object, then register services.

* Decompose your module in 5 parts:
{{{_createdb.sql}}} SQL creation of databases
{{{_sql.ml}}} database requests, using lwt-pgocaml and lwt_pool
{{{.ml}}} defining and exporting session data for the module (see below)
{{{_cache.ml}}} cache on database requests, using the Cache module
{{{_widgets.ml}}} your widgets

For all cached requests, I use a name ending with {{{_}}} in {{{*_sql.ml}}}
to and without
the {{{_}}} in {{{*cache.ml}}}
to remember that we must not call the functions from
{{{_sql.ml}}} directly.

* Use as much as possible the same naming scheme for methods.
For example:
 * {{{private retrieve_data}}} or {{{retrieve_}}}...
 * {{{private display}}} or {{{display_...}}}
 for displaying the widget from retrieved data
 * public methods for each widget you want to be able to put in your pages
(possibly in wikipages), that will:
  # check permissions
  # call {{{retrieve_...}}}
  # call {{{display_...}}}
For example: public method {{{oldversion_wikibox}}} will call {{{retrieve_old_wikibox}}}
and {{{display_old_wikibox}}}

* Use as much as possible the same names for labels.

* Each widget takes an optional {{{?classe}}} label of type string list
for the {{{class}}} xhtml attribute. Each widget has its own attribute names

* Session data:
most widgets take {{{~sp}}} as parameter (Eliom's server parameters) and also
a {{{~sd}}} parameter (session data).
This {{{~sd}}} parameter is a cache of session data, to avoid retrieving
them from the db for each box, if several boxes need them.
It has type {{{Ocsimore_common.session_data = Polytables.t}}}
(polymorphic table).
This allows each module (forum, wiki...) to save its own data inside.
To do that, each module must create its own polytable key.
This data is usually a record with lazy values or tables inside 
to prevent data to be retrieved if not necessary of if it has already been done.
You must create a new {{{~sd}}} for each request using
{{{Ocsimore_common.create_sd (it is destroyed at the end).
See for example {{{wiki.ml}}}.

Is it really useful? Actually I use it only for few things. For most cases,
we use a cache of sql requests.

Warning: Polytables is not thread-safe. 
Do not use function that access {{{~sd}}} inside {{{Lwt_preemptive.detach!}}}

When doing an action, DO NOT FORGET to send the session data to the
subsequent service by returning the exception Ocsimore_common.Session_data.
At the beginning of a service handler, call Ocsimore_common.get_sd
that will get the previous sd if it exists, or create a new one otherwise.

* Catching exceptions:
To be sure that all exceptions occurring during a db request are catched
and result in an error message in the box, I use the method
{{{Widget.widget_with_error_box#bind_or_display_error}}}

* Creating new wiki extensions:
If you create a new box, you probably want to have a syntax to place it
inside a wikibox. To so that, use the functions Wiki_syntax.add_block_extension
and Wiki_syntax.add_inline_extension. 
If you want a preparsing (i.e. do some action before saving the wikibox in
the database, like creating a new wikibox for {{{~<<wikibox box='new'>>}}}),
use the function {{{Wiki_filter.add_preparser_extension}}}.
If your box can contain wiki syntax,
(for example {{{~<<div|content>>}}}) do not forget to call
Wiki_filter.add_preparser_extension as in Wiki_syntax.ml (div)
to preparse the content recursively.
(!!!Very dangerous: should be done automatically!!!)
See examples in {{{wiki_syntax.ml}}} and {{{wiki_widgets.ml}}}

* Groups
Groups and users are the same notion. The only difference is that users have
a password. A user can belong to a group that belongs to another group, etc.
It is recommanded to create groups for each task you want. For example:
readers of wiki 1, writers of wiki 1, and then put users inside.
Predefined users/groups:
 - admin: a special user who belongs to all groups
 - anonymous: non authenticated user
 - users: group of authenticated users
 - nobody: a special user with no right at all 
 (for ex when the user does not exist)

When creating a new extension, create a group for each possible action
(for example "write in the forum number 4", "edit page css for wiki 3"...).
Then set the relations between these groups.

You probably want to compute the permission for one user at the
beginning of the request. To do that, create a record with boolean
fields for each possible action (for one forum, one box in a wiki, one
wiki, etc). The function that will compute this can be memoised in sd
to avoid to compute several times the same thing. See forum.ml for an
example.


* Wiki
Warning: if the wiki is associated to a path, we register an Eliom service
with suffix at this URL. The table wikipages associate a pair (path, wiki_id)
to a wikibox number in this wiki. It is not possible for now to associate a
box from another wiki. But you can create a sub-box that belongs to another 
wiki.


